---
title: "Elixir ç»ƒæ‰‹ + å®æˆ˜ï¼šçŸ­é“¾æ¥æœåŠ¡"
subtitle: "åŸºäº Elixir + Plug + Ecto(PostgreSQL) å®ç°çŸ­é“¾æ¥æœåŠ¡"
date: 2022-04-22T20:51:10+02:00
draft: false
tags: ["Elixir"]
categories: ["ä»å…¥é—¨ åˆ°å…¥åŸ"]
image: 
description: "åŸºäº Elixir + Plug + Ecto(PostgreSQL) å®ç°çŸ­é“¾æ¥æœåŠ¡"
---

<!-- 
![](https://mogeko.github.io/blog-images/r/092/)
{{< spoiler >}}{{< /spoiler >}}
&emsp;&emsp;
 -->

å‰å‡ å‘¨ï¼Œåœ¨æˆ‘çš„è½¯ç£¨ç¡¬æ³¡ä¸‹ï¼Œç»ˆäºä¸å¯¼å¸ˆä¸€èµ·æ•²å®šäº†è®ºæ–‡çš„ Work Planã€‚

å…¶ä¸­åç«¯æœåŠ¡å™¨çš„æŠ€æœ¯è·¯çº¿æˆ‘é€‰æ‹©äº† Elixirã€‚é€‰æ‹© Elixir å¹¶ä¸å› ä¸ºæˆ‘ Elixir æœ‰å¤šç‰›ï¼›ç›¸åï¼Œæˆ‘ä¹Ÿæ˜¯å› ä¸ºè¿™ç¯‡è®ºæ–‡æ‰å¼€å§‹çœŸæ­£å¼€å§‹æ¥è§¦ Elixir çš„ (çº¯æ–°æ‰‹)ã€‚åœ¨å•ƒå®Œ[å®˜æ–¹æŒ‡å—](https://elixir-lang.org/getting-started/introduction.html) å’Œ [Elixir School](https://elixirschool.com/zh-hans) ä¸­æ„Ÿå…´è¶£çš„éƒ¨åˆ†åï¼Œå†³å®šè¶çƒ­æ‰“é“ï¼Œä¸Šä¸€äº›çœŸæ­£çš„é¡¹ç›®æ¥ç»ƒç»ƒæ‰‹ã€‚

ç„¶åå°±æ‰¾åˆ°äº†è¿™ç¯‡åšå®¢ï¼š[How to write a super fast link shortener with Elixir, Phoenix, and Mnesia](https://medium.com/free-code-camp/how-to-write-a-super-fast-link-shortener-with-elixir-phoenix-and-mnesia-70ffa1564b3c)ï¼Œè¿™æ˜¯ä¸€ç¯‡éå¸¸ä¼˜ç§€çš„æ–‡ç« ï¼Œéå¸¸è¯¦å°½çš„ä»‹ç»äº†å¦‚ä½•é€šè¿‡ Elixir, Phoenix å’Œ Mnesia æ¥å®ç°ä¸€ä¸ªçŸ­é“¾æ¥æœåŠ¡ã€‚

â€œéå¸¸å¥½ï¼å°±ç”¨å®ƒç»ƒæ‰‹å§ï½ï½â€ï¼Œæˆ‘å¿ƒä¸­é»˜å¿µé“ï¼Œâ€œä¸è¿‡è¦æŒ‰ç…§æˆ‘çš„æ–¹æ³•æ¥â€ã€‚

äºæ˜¯ï¼Œä¾¿æœ‰äº†è¿™ç¯‡æ–‡ç« ã€‚åŒæ ·çš„ä¸»é¢˜ï¼šçŸ­é“¾æ¥æœåŠ¡ï¼›ä¸è¿‡æˆ‘çš„æŠ€æœ¯è·¯çº¿æ˜¯ **Elixir** + **Plug** + **Ecto(PostgreSQL)**ã€‚é€‰æ‹© Plug è€Œä¸ç”¨ Phoenix çš„åŸå› å¹¶é Phoenix ä¸å¥½ç”¨ï¼Œè€Œæ˜¯å› ä¸º Phoenix å®åœ¨æ˜¯å¤ªå¥½ç”¨äº†ï¼Phoenix éƒ½å¸®ä½ å®ç°å®Œäº†ï¼Œä½ è¿˜å­¦ä»€ä¹ˆï¼Ÿå†è€…ï¼ŒPhoenix å°±æ˜¯åŸºäº Plug å®ç°çš„ï¼Œ**æ–°æ‰‹å°±æ˜¯åº”è¯¥é€ è½®å­ï¼ï¼**

ä¸ºä»€ä¹ˆé€‰ PostgreSQLï¼ŸğŸ‘€ å•çº¯æ˜¯å› ä¸ºä»¥å‰ç”¨è¿‡ï¼Œæ¯”è¾ƒç†Ÿæ‚‰ã€‚è¯´æ¥æƒ­æ„§ï¼Œä½œä¸ºä¸€åé Erlang å‡ºç”Ÿçš„ Elixirerï¼Œæˆ‘æ˜¯ç¬¬ä¸€æ¬¡å¬è¯´ Mnesia è¿™ä¸ªæ•°æ®åº“ã€‚å¹¶ä¸”ï¼Œ~~Ecto å’Œ PostgreSQL æ‰æ˜¯åŸé…å¥½å—ï¼Ÿï¼CPé”æ­» (é›¾~~

è¯´äº†åŠå¤©è¿˜æ²¡è¿›å…¥æ­£é¢˜ï¼Œä½†æˆ‘è¿˜æƒ³å†å¤šå•°å—¦ä¸¤å¥ï¼›æ€»çš„æ¥è¯´ï¼Œ**è¿™å¹¶ä¸æ˜¯ä¸€ç¯‡æ•™ç¨‹ï¼ï¼**æˆ‘åªæ˜¯å¸Œæœ›ç»™å¤§å®¶æä¾›ä¸€äº›æ€è·¯ï¼Œè€Œä¸æ˜¯è¯•å›¾æ•™ä¼šä½ äº›ä»€ä¹ˆ (æˆ‘ä¸€ä¸ªå¤§ä¸‰ç‹—ï¼Œæœ‰ä»€ä¹ˆèµ„æ ¼æ•™ä½ å˜› \_(:Â°Ğ·ã€âˆ )\_)ï¼›å¦‚æœä½ åœ¨åšçš„æ—¶å€™ï¼Œæœ‰æ›´å¥½çš„æƒ³æ³•ï¼Œ**æŒ‰ç…§ä½ çš„æƒ³æ³•å®ç°å®ƒï¼ï¼**å¦‚æœä½ æ„¿æ„çš„è¯ï¼Œé€šè¿‡ [Issues](https://github.com/mogeko/link-shortener-api/issues) å‘Šè¯‰æˆ‘ï¼›åŒæ ·çš„ï¼Œæœ‰ä¸æ‡‚çš„ä¹Ÿå¯ä»¥åœ¨ Issues é‡Œé¢æï¼Œæˆ‘æœ‰ç©ºå°½é‡å¸®ä½ ï¼Œæˆ‘ä¹Ÿå¸®ä¸äº†ä½ çš„å¤§å®¶ä¸€èµ·è®¨è®ºè§£å†³âœŒï¸ã€‚è™½ç„¶æˆ‘ä¹Ÿæ˜¯ä¸ªå‡ å‘¨å‰æ‰å¼€å§‹å…¥é—¨ Elixir çš„æ–°æ‰‹ï¼Œä½†æœ‰ä¸€è¯´ä¸€ï¼Œç†Ÿæ‚‰ LISP åå†ä¸Šæ‰‹ Elixir æ˜¯çœŸçš„å¾ˆçˆ½ï¼ï¼ (æ„Ÿè°¢ _**Functional Programming**_ è¿™é—¨å™©æ¢¦èˆ¬çš„è¯¾ç¨‹å¯¹æˆ‘çš„è¹‚èº \_(:Â°Ğ·ã€âˆ )\_)

## æ­£ç‰‡å¼€å§‹

æœ¬é¡¹ç›®çš„å®Œæ•´ä»£ç å¯ä»¥åœ¨ GitHub ä¸­è·å–ï¼š[mogeko/link-shortener-api](https://github.com/mogeko/link-shortener-api)

å…·ä½“å®ç°å¯èƒ½æœ‰äº›å¾®å·®åˆ«ï¼›æœ¬æ–‡ä¸ºäº†ç®€ä¾¿ï¼Œå·²ç»ç•¥å»äº†æ‰€æœ‰çš„æ–‡æ¡£å’Œæµ‹è¯•éƒ¨åˆ†çš„ä»£ç ã€‚

å¦‚æœä½ æ˜¯ Elixir æ–°æ‰‹çš„è¯ï¼Œååˆ†æ¨èä½ èŠ± 10 åˆ†é’Ÿè¯»ä¸€ä¸‹é€¼ä¹ä¸Š [ç»…å£«å–µ](https://www.zhihu.com/people/Hentioe) çš„è¿™ç¯‡å›ç­”ï¼š[å¦‚ä½•ç³»ç»Ÿåœ°å­¦ä¹  Elixirï¼Ÿ](https://www.zhihu.com/question/331635817/answer/842108558)ï¼Œä¼šå¯¹ä½ çš„ Elixir å­¦ä¹ ç”Ÿæ´»æœ‰å¾ˆå¤§å¸®åŠ©çš„ï¼

### å‡†å¤‡å·¥ä½œ

é¦–å…ˆæ˜¯å‡†å¤‡å·¥ä½œï¼Œä½ éœ€è¦å…ˆåœ¨ä½ çš„ç”µè„‘ä¸Šå‡†å¤‡å¥½ï¼š

- Elixir, website: <https://elixir-lang.org>
- PostgreSQL, website: <https://www.postgresql.org>

å®‰è£… Elixir å¯ä»¥å‚è€ƒ[è¿™ç¯‡æ–‡ç« ](https://elixir-lang.org/install.html), PostgreSQL çš„å®‰è£…åŒ…å¯ä»¥åœ¨[è¿™é‡Œæ‰¾åˆ°](https://www.postgresql.org/download)ã€‚

æˆ‘ä»¬å‡è®¾ä½ ä¼š [Elixir](https://hexdocs.pm/elixir/Kernel.html) çš„è¯­æ³•ï¼Œå¹¶å¯¹ [Plug](https://hexdocs.pm/plug/readme.html) å’Œ [Ecto](https://hexdocs.pm/ecto/Ecto.html) æœ‰ä¸€å®šäº†è§£ï¼›å¹¶ä¸”æ‹¥æœ‰å¯¹ PostgreSQL è¿›è¡ŒåŸºæœ¬å®‰è£…é…ç½®çš„çŸ¥è¯†ã€‚

å¦‚æœä½ ä¸ä¼š Elixir æˆ–è€…ä¸çŸ¥é“ Plug å’Œ Ecto æ˜¯ä»€ä¹ˆï¼Œä½ å¯èƒ½éœ€è¦å…ˆå» [Elixir å®˜æ–¹æŒ‡å— (åŸºç¡€)](https://elixir-lang.org/getting-started/introduction.html) å’Œ [Elixir School](https://elixirschool.com/zh-hans) å­¦ä¹ ä¸€ä¸‹ã€‚

å…³äº PostgreSQL æˆ‘æ‰‹ä¸Šç›®å‰æ²¡æœ‰ä»€ä¹ˆå¥½çš„ææ–™ï¼Œä½†åƒ PostgreSQL è¿™ä¹ˆæµè¡Œçš„æ•°æ®åº“çš„å®‰è£…é…ç½®æ•™ç¨‹ç½‘ä¸Šè‚¯å®šä¸€æœä¸€å¤§æŠŠã€‚

### åˆ›å»º Elixir é¡¹ç›®

è£…å¥½ Elixir åï¼Œåœ¨ä½ çš„å·¥ä½œç›®å½•ä¸­æ–°å»ºä¸€ä¸ªé¡¹ç›®ï¼š

```bash
mix new shorten_api --sup
```

ç„¶åè¿›å…¥ `shorten_api` (ä»ç°åœ¨å¼€å§‹é»˜è®¤ä½ çš„å·¥ä½œç›®å½•ä¸º `shorten_api`)ï¼Œåœ¨ `./mix.exs` ä¸­æ·»åŠ ä¾èµ–é¡¹ï¼š

```./mix.exs
defp deps do
  [
    {:plug_cowboy, "~> 2.0"},
    {:ecto_sql, "~> 3.2"},
    {:postgrex, "~> 0.15"},
    {:jason, "~> 1.3"}
  ]
end
```

ä» [Hex](https://hex.pm) è·å–ä¾èµ–é¡¹ï¼š

```bash
mix deps.get
```

### åˆ†æé—®é¢˜

æˆ‘ä»¬å…ˆåˆ†æé—®é¢˜ï¼Œæˆ‘ä»¬çš„éœ€æ±‚æ˜¯ä¸€ä¸ªçŸ­é“¾æ¥æœåŠ¡ï¼Œ**å®ƒçš„æ ¸å¿ƒæ˜¯å°†æ¥æ”¶åˆ°çš„é“¾æ¥ Hash åŒ–**ã€‚

å…¶åˆ›å»ºçŸ­é“¾æ¥çš„ä¸»è¦å·¥ä½œæµç¨‹ä¸ºï¼š

1. API é€šè¿‡ GET æˆ– POST æ–¹æ³•è·å–éœ€è¦å¤„ç†çš„é“¾æ¥
2. å°†é“¾æ¥ Hash åŒ– (æ ¸å¿ƒ)
3. å°† Hash å’Œé“¾æ¥å­˜å…¥æ•°æ®åº“
4. å°†ç”Ÿæˆçš„çŸ­é“¾æ¥ (å³ `https://:host_url/:hash`) è¿”å›ç»™ç”¨æˆ·

ä¸ä¹‹ç›¸åº”çš„ï¼Œå…¶æŸ¥è¯¢é€»è¾‘çš„ä¸»è¦å·¥ä½œæµç¨‹ä¸ºï¼š

1. ç”¨æˆ· `GET /:hash`
2. åœ¨æ•°æ®åº“ä¸­æŸ¥è¯¢ `:hash` å¯¹åº”çš„é“¾æ¥
3. é‡å®šå‘ (302) åˆ°æŒ‡å®šé“¾æ¥

## åˆ›å»ºçŸ­é“¾æ¥

### å°†é“¾æ¥HashåŒ–

æˆ‘ä»¬å…ˆæ¥å®ç°æ ¸å¿ƒåŠŸèƒ½ï¼šå°†é“¾æ¥HashåŒ– **(2)**ã€‚

è®©æˆ‘ä»¬åˆ›å»ºæ–‡ä»¶ `./lib/shorten_api/hash_id.ex`

```./lib/shorten_api/hash_id.ex
defmodule ShortenApi.HashId do

  @hash_id_length 8

  @spec generate(String.t() | any()) :: :error | {:ok, String.t()}
  def generate(text) when is_binary(text) do 
    hash_id = text
    |> (&:crypto.hash(:sha, &1)).()
    |> Base.encode64
    |> binary_part(0, @hash_id_length)
    {:ok, hash_id}
  end

  def generate(_any), do: :error
end
```

`ShortenApi.HashId.generate/1` å°†æ‰€æœ‰ä¼ å…¥çš„ String Hash åŒ–ï¼Œç„¶åæˆªå–å…¶å‰ 8 ä½ (æ¯”åŸé“¾æ¥è¿˜é•¿å«ä»€ä¹ˆçŸ­é“¾æ¥ï¼Ÿ)ã€‚

è¯´å®è¯ï¼Œå°† Hash æˆªå–å‰ 8 ä½ä½¿ç”¨ä¼šæœ‰æ¦‚ç‡å‘ç”Ÿ Hash ç¢°æ’ï¼Œä½†è€ƒè™‘åˆ°å®é™…æƒ…å†µï¼Œè¿™ç§æ¦‚ç‡æ¯”è¢«é›·åŠˆè¿˜ä½ï¼ä½œä¸ºç»ƒæ‰‹é¡¹ç›®æ¥è¯´å·²ç»è¶³å¤Ÿäº†ã€‚

è¿™ä¸ªå‡½æ•°è¿”å›çš„ç±»å‹ä¸º `:error | {:ok, String.t()}`ï¼Œ`:error` å¯¹åº”ä¼ å…¥å‚æ•°ä¸æ˜¯ String çš„æƒ…å†µï¼Œ`{:ok, String.t()}` è¿™æ˜¯æ­£å¸¸æƒ…å†µï¼›ç›®å‰å…ˆè¿™æ ·å®ç°ï¼Œåé¢ä¼šå¯¹å…¶è¿›è¡Œé‡æ„ã€‚

### æå®šæœåŠ¡å™¨

ç„¶åæˆ‘çš„æ€è·¯æ˜¯å…ˆæå®šæœåŠ¡å™¨ (å³å…ˆå®ç° **(1)** **(4)**)ï¼Œå†å»ç®¡æ•°æ®åº“ã€‚

æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª Routerï¼Œæ¥ç®¡ç†æ‰€æœ‰çš„å…¥ç«™æµé‡ï¼š

```./lib/shorten_api/router.ex
defmodule ShortenApi.Router do
  use Plug.Router
  import Plug.Conn

  plug Plug.Logger
  plug Plug.Parsers, parsers: [:urlencoded, :json], json_decoder: Jason
  plug :match
  plug :dispatch

  get "/" do
    [host_url | _tail] = get_req_header(conn, "host")
    res = Jason.encode!(%{message: "#{conn.scheme}://#{host_url}/api/v1"})
    conn
    |> put_resp_content_type("application/json")
    |> send_resp(200, res)
  end

  forward "/api/v1", to: ShortenApi.Plug.REST

  match _ do
    res = Jason.encode!(%{message: "Not Found"})
    conn
    |> put_resp_content_type("application/json")
    |> send_resp(404, res)
  end
end
```

éå¸¸ç®€å•çš„è·¯ç”±ï¼ŒåŒ¹é… `GET /` å±•ç¤ºæ¬¢è¿ä¿¡æ¯ï¼Œå¤„ç† `404 Not Found`ã€‚

é‡ç‚¹åœ¨ç¬¬ 18 è¡Œï¼š

```elixir
forward "/api/v1", to: ShortenApi.Plug.REST
```

å®ƒå°†æ‰€æœ‰çš„ `/api/v1/*` çš„æµé‡è½¬å‘ç»™äº† `ShortenApi.Plug.REST`ï¼›è¿™ä¹Ÿå°±æ˜¯æˆ‘ä»¬å°†è¦å®ç°çš„ Plugï¼Œå®ƒè´Ÿè´£å¤„ç†æœåŠ¡å™¨ç”ŸæˆçŸ­é“¾æ¥çš„ä¸»è¦é€»è¾‘ **(1)** **(4)**ã€‚

```./lib/shorten_api/plug/rest.ex
defmodule ShortenApi.Plug.REST do
  @behaviour Plug
  import Plug.Conn

  @spec init(Plug.opts()) :: Plug.opts()
  def init(opts), do: opts

  @spec call(Plug.Conn.t(), Plug.opts()) :: Plug.Conn.t()
  def call(conn, _opts) do
    resp_msg = with {:ok, url} <- Map.fetch(conn.params, "url") do
      hortenApi.HashId.generate(url)
    end

    conn
    |> put_resp_content_type("application/json")
    |> put_resp_msg(resp_msg)
    |> send_resp()
  end

  @spec put_resp_msg(Plug.Conn.t(), :error | {:ok, String.t()}) :: Plug.Conn.t()
  def put_resp_msg(conn, {:ok, hash_id}) do
    [host_url | _tail] = get_req_header(conn, "host")
    res = Jason.encode!(%{ok: true, short_link: "#{conn.scheme}://#{host_url}/#{hash_id}"})
    resp(conn, 201, res)
  end

  def put_resp_msg(conn, :error) do
    res = Jason.encode!(%{ok: false, message: "Parameter error"})
    resp(conn, 404, res)
  end
end
```

è¿™ä¸ª Plug é¦–å…ˆä» `conn.params` ä¸­è¯»å–é“¾æ¥ï¼Œç„¶åè°ƒç”¨å‡½æ•° `ShortenApi.HashId.generate/1` å¤„ç†é“¾æ¥ï¼Œå†è°ƒç”¨ `put_resp_msg/2` å°†å¤„ç†å¥½çš„ Hash ä¸ä¸»æœºåœ°å€æ‹¼æ¥åœ¨ä¸€èµ·ï¼Œé™„åŠ åˆ° `conn` ä¸­ï¼Œæœ€åè¿”å›ç»™ç”¨æˆ·ã€‚

é¡ºä¾¿ä¸€æï¼Œ`conn.params` çš„å¤„ç†æ˜¯åœ¨ `Plug.Parsers` è¿™ä¸ª Plug ä¸­å®Œæˆçš„ã€‚å…¶çš„è°ƒç”¨åœ¨ `./lib/shorten_api/router.ex` çš„ç¬¬ 6 è¡Œã€‚

åˆ«å¿˜äº†å°† `ShortenApi.Router` ä¸¢ç»™ç›‘ç®¡è€… (Supervisor) å¯åŠ¨ï¼š

```./lib/shorten_api/application.ex
def start(_type, _args) do
  children = [
    {Plug.Cowboy, scheme: :http, plug: ShortenApi.Router, options: [port: 8080]}
  ]

  opts = [strategy: :one_for_one, name: ShortenApi.Supervisor]

  Logger.info("Starting application...")

  Supervisor.start_link(children, opts)
end
```

### å¤„ç†æ•°æ®åº“

æ¥ç€æˆ‘ä»¬æ¥å¤„ç†æ•°æ®åº“ã€‚

é¦–å…ˆæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ•°æ®åº“ (Ecto.Repo) å’Œä¸€å¼ è¡¨ (Ecto.Migration)ï¼š

```./lib/shorten_api/repo.ex
defmodule ShortenApi.Repo do
  use Ecto.Repo,
    otp_app: :shorten_api,
    adapter: Ecto.Adapters.Postgres
end
```

```./priv/repo/migrations/*_create_links.exs
defmodule ShortenApi.Repo.Migrations.CreateLinks do
  use Ecto.Migration

  def change do
    create table(:links, primary_key: false) do
      add :hash, :string, primary_key: true, null: false
      add :url, :string, null: false

      timestamps()
    end

    create unique_index(:links, [:url])
  end
end
```

ç„¶åæ ¹æ®è¡¨ç¼–å†™ Schemaï¼š

```./lib/shorten_api/db/link.ex
defmodule ShortenApi.DB.Link do
  use Ecto.Schema

  @primary_key {:hash, :string, [autogenerate: false]}
  schema "links" do
    field(:url, :string)
    timestamps()
  end
end
```

ç¼–å†™ `changeset/2` ç”¨äºæ ¡éªŒå†™å…¥æ•°æ®åº“çš„æ•°æ®æ˜¯å¦åˆæ³•ï¼Œå¯¹å¤–æš´éœ²ä¸€ä¸ª `write/2` å‡½æ•°ç”¨äºå°†æ•°æ®å†™å…¥æ•°æ®åº“ã€‚

```./lib/shorten_api/db/link.ex
defmodule ShortenApi.DB.Link do
  import Ecto.Changeset

  @spec changeset(Ecto.Schema.t() | map, map) :: Ecto.Changeset.t()
  def changeset(struct, params) do
    struct
    |> cast(params, [:hash, :url])
    |> validate_required([:hash, :url])
    |> validate_format(:url, ~r/htt(p|ps):\/\/(\w+.)+/)
    |> validate_hash_matched(:hash, :url)
    |> unique_constraint(:url)
  end

  @spec validate_hash_matched(Ecto.Changeset.t(), atom, atom) :: Ecto.Changeset.t()
  def validate_hash_matched(changeset, hash, text) do
    import ShortenApi.HashId, only: [generate!: 1]
    target_hash = get_field(changeset, hash)
    target_text = get_field(changeset, text)

    if generate!(target_text) != target_hash do
      add_error(changeset, :hash, "does not match target link")
    else
      changeset
    end
  end

  @spec write(String.t(), String.t()) :: {:ok, Ecto.Schema.t()} | {:error, Ecto.Changeset.t()}
  def write(hash, url) do
    %ShortenApi.DB.Link{}
    |> changeset(%{hash: hash, url: url})
    |> ShortenApi.Repo.insert()
  end
end
```

å€¼å¾—ä¸€æçš„æ˜¯æˆ‘ä»¬é€šè¿‡ `validate_hash_matched/3` å®ç°äº†å¯¹é“¾æ¥æ˜¯å¦åŒ¹é…å…¶ç”Ÿæˆçš„ Hash çš„æ ¡éªŒï¼›å…¶ä¸­éœ€è¦è®© `ShortenApi.HashId.generate/1` ç›´æ¥è¿”å›ç”Ÿæˆçš„ Hash å€¼ï¼Œå› æ­¤æˆ‘ä»¬ç”¨ `ShortenApi.HashId.generate!/1` å°† `ShortenApi.HashId.generate/1` ä¸­ç”Ÿæˆ Hash å€¼çš„éƒ¨åˆ†é€»è¾‘æŠ½ç¦»å‡ºæ¥ï¼Œå¹¶å¯¹ `ShortenApi.HashId.generate/1` è¿›è¡Œé‡æ„ï¼Œä½† `ShortenApi.HashId.generate/1` åŸæœ¬çš„æ¥å£æ˜¯ä¸å˜çš„ã€‚

```./lib/shorten_api/hash_id.ex
defmodule ShortenApi.HashId do

  @hash_id_length 8

  @spec generate(String.t() | any()) :: :error | {:ok, String.t()}
  def generate(text) when is_binary(text), do: {:ok, generate!(text)}
  def generate(any), do: :error

  @spec generate!(String.t() | any()) :: :error | String.t()
  def generate!(text) when is_binary(text) do
    text
    |> (&:crypto.hash(:sha, &1)).()
    |> Base.encode64()
    |> binary_part(0, @hash_id_length)
  end

  def generate!(_any), do: :error
end
```

æ­£å¸¸æƒ…å†µä¸‹ï¼Œ`generate!/1` çš„è¿”å›ç±»å‹åº”è¯¥ä¸º `String.t()`ï¼Œå¦‚æœå…¶ä¸­å‘ç”Ÿé”™è¯¯ï¼Œåº”å½“ç›´æ¥æŠ›å‡ºé”™è¯¯ï¼ŒCrash æ‰æ•´ä¸ªç¨‹åºã€‚è¿™é‡Œä¸ºäº†ç®€ä¾¿æ²¡æœ‰å®ç°ç›¸å…³çš„é€»è¾‘ã€‚

åŒæ ·çš„ï¼Œä¸è¦å¿˜äº†åœ¨ `ShortenApi.Application` ä¸­å¯åŠ¨ `ShortenApi.Repo`ï¼š

```./lib/shorten_api/application.ex
def start(_type, _args) do
  children = [
    {Plug.Cowboy, scheme: :http, plug: ShortenApi.Router, options: [port: 8080]},
    ShortenApi.Repo
  ]

  opts = [strategy: :one_for_one, name: ShortenApi.Supervisor]

  Logger.info("Starting application...")

  Supervisor.start_link(children, opts)
end
```

è‡³æ­¤ï¼Œä¸ºäº†å®ç°å°† Hash å’Œé“¾æ¥å­˜å…¥æ•°æ®åº“ **(3)** è¿™ä¸€åŠŸèƒ½çš„å‡†å¤‡å·¥ä½œå°±å®Œæˆäº†ã€‚

### å°†æœåŠ¡å™¨ä¸æ•°æ®åº“è¿æ¥èµ·æ¥

ç°åœ¨æˆ‘ä»¬å·²ç»æ‹¥æœ‰äº†æ ¡éªŒå’Œå†™å…¥æ•°æ®åº“çš„èƒ½åŠ›äº†ã€‚æˆ‘ä»¬éœ€è¦åœ¨æˆ‘ä»¬çš„ `ShortenApi.Plug.REST` ä¸­è°ƒç”¨ç›¸åº”çš„å‡½æ•°ï¼Œå®ç°åŠŸèƒ½ã€‚

é¦–å…ˆéœ€è¦é‡æ„ `ShortenApi.Plug.REST.call/2`ï¼š

```./lib/shorten_api/plug/rest.ex
defmodule ShortenApi.Plug.REST do
  @behaviour Plug
  import Plug.Conn

  @spec init(Plug.opts()) :: Plug.opts()
  def init(opts), do: opts

  @spec call(Plug.Conn.t(), Plug.opts()) :: Plug.Conn.t()
  def call(conn, _opts) do
    resp_msg =
      with {:ok, url} <- Map.fetch(conn.params, "url"),
           {:ok, hash} <- ShortenApi.HashId.generate(url) do
        ShortenApi.DB.Link.write(hash, url)
      end

    conn
    |> put_resp_content_type("application/json")
    |> put_resp_msg(resp_msg)
    |> send_resp()
  end
end
```

ç„¶åæˆ‘ä»¬å°±ä¼šå‘ç°ï¼Œ`put_resp_msg/2` æ¥æ”¶åˆ°çš„å‚æ•°ç±»å‹ä» `Plug.Conn.t(), :error | {:ok, String.t()}` å˜æˆäº† `Plug.Conn.t(), :error | {:error, Ecto.Changeset.t()} | {:ok, Ecto.Schema.t()}`ï¼›å› æ­¤ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å¯¹ `put_resp_msg/2` è¿›è¡Œé‡æ„ï¼š

```./lib/shorten_api/plug/rest.ex
defmodule ShortenApi.Plug.REST.Resp do
  @derive Jason.Encoder
  defstruct ok: true, short_link: ""
  @type t :: %__MODULE__{ok: boolean, short_link: String.t()}
end

defmodule ShortenApi.Plug.REST.ErrResp do
  @derive Jason.Encoder
  defstruct ok: false, message: ""
  @type t :: %__MODULE__{ok: boolean, message: String.t()}
end

defmodule ShortenApi.Plug.REST do
  @behaviour Plug
  import Plug.Conn

  @spec put_resp_msg(
          Plug.Conn.t(),
          :error | {:error, Ecto.Changeset.t()} | {:ok, Ecto.Schema.t()}
        ) :: Plug.Conn.t()
  def put_resp_msg(conn, {:ok, struct}) do
    alias ShortenApi.Plug.REST.Resp
    [host_url | _tail] = get_req_header(conn, "host")
    short_link = "#{conn.scheme}://#{host_url}/#{struct.hash}"
    resp_json = Jason.encode!(%Resp{short_link: short_link})
    resp(conn, 201, resp_json)
  end

  def put_resp_msg(conn, {:error, _changeset}) do
    alias ShortenApi.Plug.REST.ErrResp
    resp_json = Jason.encode!(%ErrResp{message: "Wrong format"})
    resp(conn, 403, resp_json)
  end

  def put_resp_msg(conn, :error) do
    alias ShortenApi.Plug.REST.ErrResp
    resp_json = Jason.encode!(%ErrResp{message: "Parameter error"})
    resp(conn, 404, resp_json)
  end
end
```

è¿™é‡Œæˆ‘ä»¬ä¸ä»…é‡æ„äº† `put_resp_msg/2`ï¼Œè¿˜ä½¿ç”¨äº†ä¸¤ä¸ªç»“æ„ä½“ `ShortenApi.Plug.REST.ErrResp` å’Œ `ShortenApi.Plug.REST.Resp` æ¥å¸®åŠ©æˆ‘ä»¬å¤„ç†è¿”å›ç»™ç”¨æˆ·çš„æ•°æ®ã€‚

è¿™é‡Œå¯¹ `put_resp_msg/2` å¤„ç†é”™è¯¯ä¿¡æ¯çš„æ–¹å¼éå¸¸çš„ç®€å•ç²—æš´ï¼›äº‹å®ä¸Šï¼ŒChangeset æä¾›äº†éå¸¸å®Œå–„çš„é”™è¯¯ä¿¡æ¯ï¼Œä»¥æ–¹ä¾¿æˆ‘ä»¬å¯ä»¥æ›´å¥½çš„å¤„ç†æ­¤ç±»é—®é¢˜ã€‚

è‡³æ­¤ï¼Œåˆ›å»ºçŸ­é“¾æ¥çš„ä¸»è¦å·¥ä½œæµç¨‹ **(1)** **(2)** **(3)** **(4)** éƒ½å·²ç»å®Œæˆäº†ã€‚

### æµ‹è¯•åˆ›å»ºçŸ­é“¾æ¥

æˆ‘ä»¬å…ˆå¯åŠ¨æˆ‘ä»¬çš„æœåŠ¡å™¨ï¼š

```bash
mix run --no-halt
```

ç„¶åå¦å¤–æ‰“å¼€ä¸€ä¸ªç»ˆç«¯ï¼Œä½¿ç”¨ GET æˆ– POST æ–¹æ³•å‘æˆ‘ä»¬çš„æœåŠ¡å™¨å‘æ¶ˆæ¯ï¼š

```bash
curl --request POST \
  --url http://localhost:8080/api/v1 \
  --header 'content-type: application/json' \
  --data '{
    "url": "https://mogeko.me/posts/zh-cn/092"
  }'
```

ä¸å‡ºæ„å¤–çš„è¯ï¼Œä½ å¯ä»¥çœ‹è§è¿”å›å€¼ï¼š

```json
{
  "ok": true,
  "short_link": "http://localhost:8080/D9mP2G8N"
}
```

`http://localhost:8080/i0sm8Q+T` å°±æ˜¯ä½ çš„çŸ­é“¾æ¥äº†ï¼Œä½†ä½ ç°åœ¨è¿˜ä¸èƒ½ä½¿ç”¨å®ƒã€‚

## æŸ¥è¯¢çŸ­é“¾æ¥

æˆ‘ä»¬å³å°†å®ç°æŸ¥è¯¢çŸ­é“¾æ¥çš„é€»è¾‘ã€‚

å¾ˆç®€å•ï¼Œåœ¨ `ShortenApi.Router` å¤„å¢åŠ ä¸€ä¸ªè·¯ç”±è§„åˆ™å³å¯ï¼š

```./lib/shorten_api/router.ex
defmodule ShortenApi.Router do
  use Plug.Router
  import Plug.Conn

  plug(Plug.Logger)
  plug(Plug.Parsers, parsers: [:urlencoded, :json], json_decoder: Jason)
  plug(:match)
  plug(:dispatch)

  get "/:hash" do
    import Ecto.Query, only: [from: 2]
    query = from l in ShortenApi.DB.Link, where: l.hash == ^hash, select: l.url
    url = ShortenApi.Repo.one(query)

    if is_nil(url) do
      conn
      |> put_resp_content_type("application/json")
      |> send_resp(404, Jason.encode!(%{message: "Not Found"}))
    else
      conn
      |> put_resp_header("location", url)
      |> send_resp(302, "Redirect to #{url}")
    end
  end
end
```

ç°åœ¨é‡å¯æˆ‘ä»¬çš„æœåŠ¡å™¨ï¼Œæ‰“å¼€æµè§ˆå™¨è®¿é—®é“¾æ¥ `http://localhost:8080/D9mP2G8N`ï¼Œå®ƒå°†ä¼šè‡ªåŠ¨è·³è½¬åˆ° <https://mogeko.me/posts/zh-cn/092>ã€‚

## ç»“æŸï¼Ÿä»…ä»…æ˜¯å¼€å§‹

æˆ‘ä»¬å·²ç»å®ç°äº†ä¸€ä¸ªå¯ä»¥ç”¨çš„çŸ­é“¾æ¥æœåŠ¡äº†ï¼ï¼ğŸ‘

ä½†æ˜¯å®ƒè¿˜ä¸å¤Ÿå®Œå–„ï¼š

- å•å…ƒæµ‹è¯•ï¼›æˆ‘ç»„ç»‡ä»£ç çš„æ–¹å¼ä¸ä»…ä»…æ˜¯åŒºåˆ†åŠŸèƒ½ï¼Œæ›´æ˜¯ä¸ºäº†ä¾¿äºå•å…ƒæµ‹è¯•ï¼å¦‚æœä½ æ„Ÿå…´è¶£çš„è¯ï¼Œå¯ä»¥è¯•ç€åšä¸€ä¸‹ï¼Œæ„Ÿå—ä¸€ä¸‹ã€‚
- ä»£ç ä¸­æœ‰éå¸¸å¤šä¸å®Œå–„çš„åœ°æ–¹ï¼Œä½ å¯ä»¥è¯•ç€å®Œå–„å®ƒä»¬ã€‚
- åˆ°ç›®å‰ä¸ºæ­¢æˆ‘ä»¬åªä½¿ç”¨äº† GET å’Œ POST æ–¹æ³•ï¼Œä½† [HTTP è¯·æ±‚æ–¹æ³•](https://developer.mozilla.org/zh-CN/docs/web/http/methods) å¯ä¸åªå®ƒä¿©ï¼Œè¯•ç€å®ç°ä¸€ä¸‹ PUT å’Œ DELETEï¼Ÿ

åœ¨æˆ‘å¼€å‘è¿‡ç¨‹ä¸­ï¼Œå¯¹æˆ‘å¸®åŠ©æœ€å¤§çš„å½“å± [HexDocs](https://hexdocs.pm)ï¼Œä»–ä»¬ä¸ä»…æä¾›äº†æˆ‘éœ€è¦çš„ API æ–‡æ¡£ï¼Œè¿˜æä¾›äº†å¾ˆå¤šçš„å®ç°å‚è€ƒï¼›éœ€è¦æ—¶å¤šç¿»ç¿»ï¼ŒçœŸçš„å¼€å·æœ‰ç›Šï¼ï¼

## å‚è€ƒåˆ—è¡¨

- [How to write a super fast link shortener with Elixir, Phoenix, and Mnesia](https://medium.com/free-code-camp/how-to-write-a-super-fast-link-shortener-with-elixir-phoenix-and-mnesia-70ffa1564b3c)
- [å¦‚ä½•ç³»ç»Ÿåœ°å­¦ä¹  Elixirï¼Ÿ - ç»…å£«å–µçš„å›ç­”](https://www.zhihu.com/question/331635817/answer/842108558)
- [HexDocs - Plug :: Compose web applications with functions](https://hexdocs.pm/plug/readme.html)
- [HexDocs - Ecto :: A toolkit for data mapping and language integrated query](https://hexdocs.pm/ecto/Ecto.html)
- [HexDocs - Jason :: A blazing fast JSON parser and generator in pure Elixir](https://hexdocs.pm/jason/readme.html)
